#under edit
name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
env:
  PROJECT_ID: ${{ secrets.GKE_PROJECT }}
  GKE_CLUSTER: yessoft1    # TODO: update to cluster name
  GKE_ZONE: us-central1-c   # TODO: update to cluster zone
  DEPLOYMENT_NAME: turkish-app-test
  IMAGE: static-site
  ORGANIZATION: yes-soft-de
  ENVREPO: environment-tools
  




# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  build:
    runs-on: ubuntu-latest
   
 

    steps:
      - uses: actions/checkout@v2
      - name: Run a multi-line script
        env: 
          REP: 123
        run: |
          source option 
          echo "RIPP=${REPO}" >> $GITHUB_ENV
          echo "envpriv=${envpriv}" >> $GITHUB_ENV
          echo "GKE_CLUSTER=${GKE_CLUSTER}" >> $GITHUB_ENV
          echo "GKE_ZONE=${GKE_ZONE}" >> $GITHUB_ENV
          echo "GHACCOUNT=${GHACCOUNT}" >> $GITHUB_ENV
          echo "TOKEN=${{ github.token }}" >> $GITHUB_ENV   
          #echo "::set-env name=REP::$REPO"
          
          echo $RIPP
          echo "${{ secrets.GITHUB_TOKEN }}" > token.txt
          gh config set -h github.com oauth_token ${{ secrets.GITHUB_TOKEN }}
          #gh auth login --with-token < token.txt
          
        
          git remote rm origin 
          #change GHACCOUNT to yessoft when u finish 
          gh repo create $GHACCOUNT/$REPO  --template=$TEMPLATE --confirm --$ACCESS
          echo repo is created 
          git remote rm origin 
          echo ${GH_USERNAME}
          git config --global user.name ${{github.actor}}
          git config --global user.email "yescloud@gmail.com"
          echo git config is done 
          sleep 15
          git clone  https://github.com/$GHACCOUNT/$REPO.git
          echo git clone is done
          cd $REPO/k8s
          echo cd is done 
          sed -i "s|FORREPLACE1235|$REPO|g" server.yaml
          sed -i "s|PROJECT123|$project|g" server.yaml
          
          sed -i "s|FORREPLACE1235|$REPO|g" secret.yaml
          echo sed 1 is done
          sed -i "s|FORREPLACE1235|$REPO|g" mysql.yaml
          echo sed 2 is done
          sed -i "s|FORREPLACE1235|$REPO|g" namespace.yaml
          sed -i "s|FORREPLACE1235|$REPO|g" configmap.yaml
          echo sed 3 is done 
          cd .. 
          project=${{secrets.GKE_PROJECT}}
          echo $project
          
          sed -i "s|PROJECT_ID123|$project|g" Dockerfile
          sed -i "s|SECRETNAME123|${REPO}sec|g" Dockerfile
          if [[ $envpriv=='true' ]]
          then
          sed -i "s|#@1||g" Dockerfile
          fi

         

          

          echo string replace is done 
         
          git remote -v
          git remote rm origin 
          echo remote remove is done
          #git remote set-url origin git@github.com:@GHACCOUNT/$REPO.git
          git remote add origin https://aliomom:${{ secrets.ghtoken }}@github.com/aliomom/$REPO.git
          ls -al
          echo ok 
          sed -i "s|FORREPLACE123|$REPO|g" .env
          cd public
          sed -i "s|FORREPLACE123|$REPO|g" .htaccess
          echo $envpriv
          if [[ $envpriv=='true' ]]
          then
            rm -rf .htaccess
            cd ..
            rm -rf .env 
          fi 
          git add .
          git commit -a -m "iit"
          #git push --set-upstream origin symfony-app-skeleton
          

          

          git push origin HEAD:symfony-app-skeleton
          cd .. 
      - uses: actions/checkout@v2
        with:
         repository: yes-soft-de/environment-tools
         token: ${{ secrets.ENVGHTOKEN }}
      - run: |
         # echo the repo is 
         # echo ${RIPP}
         mkdir -p ${RIPP} && cd ${RIPP}
         
         echo creating new directory is done
         if [[ $envpriv=='true' ]]
         then
           echo "${{ secrets.ENV }}" > .env
           echo create .env
           sed -i "s|FORREPLACE123|$RIPP|g" .env
           echo "${{ secrets.HTACCESS }}" > .htaccess
            sed -i "s|FORREPLACE123|$RIPP|g" .htaccess
           echo create .htaccess
           echo creating .env and .htaccess is done 
           echo 'FROM alpine:3.7' >> Dockerfile
           echo 'COPY . .' >> Dockerfile
            
         fi
         mkdir jwt && cd jwt
         echo creating new jwt dir
         
         openssl genpkey -out private.pem -aes256 -pass pass:${{ secrets.PASS }} -algorithm rsa -pkeyopt rsa_keygen_bits:4096 
         openssl pkey -passin pass:${{ secrets.PASS }} -in private.pem -out public.pem -pubout
         echo creating new jwt 
         ls -al 
         cd .. && ls -al
         
         git add .
         git commit -a -m "add .env and .htacces and jwt"
         git push 

         

       
      - uses: google-github-actions/setup-gcloud@v0.2.0
        with:
          service_account_key: ${{ secrets.GKE_SA_KEY }}
          project_id: ${{ secrets.GKE_PROJECT }}


      - run: |
         gcloud --quiet auth configure-docker

         echo file is generated
         #gcloud container clusters get-credentials "$GKE_CLUSTER" --zone "$GKE_ZONE"
         echo gcget
         cd $RIPP
         gcloud builds submit --tag=gcr.io/${{ secrets.GKE_PROJECT }}/${RIPP}sec
         
      - uses: actions/checkout@v2
      - uses: google-github-actions/setup-gcloud@master
        with:
          
          service_account_key: ${{ secrets.GCP_SA_KEY }}

          service_account_email: ${{ secrets.service_account_email }}
          project_id: ${{ secrets.GKE_PROJECT }}
          export_default_credentials: true
      - run: |
         gcloud container clusters get-credentials "$GKE_CLUSTER" --zone "$GKE_ZONE"
         ls -al 
         #change $ghaccount to org
         git clone  https://github.com/$GHACCOUNT/$RIPP.git
         cd $RIPP
         gcloud builds submit --tag=gcr.io/${{ secrets.GKE_PROJECT }}/${RIPP}
         cd k8s
         kubectl apply -f namespace.yaml
         sed -i "s|123secret123|${{ secrets.ROOTPASSWORD }}|g" secret.yaml
         kubectl apply -f secret.yaml
         
         kubectl apply -f configmap.yaml
         kubectl apply -f mysql.yaml
         kubectl apply -f server.yaml

          


         
